{% extends 'base.html' %}

{% block content %}
<div x-data="main" data-user-id="{{ user.username }}">
    <h2>Library Collection</h2>
    
    <div class="toast-container">
        <div x-cloak
             x-show="isRefreshing"
             x-transition:enter="transition ease-out duration-300"
             x-transition:enter-start="opacity-0 transform translate-x-full"
             x-transition:enter-end="opacity-100 transform translate-x-0"
             x-transition:leave="transition ease-in duration-300"
             x-transition:leave-start="opacity-100 transform translate-x-0"
             x-transition:leave-end="opacity-0 transform translate-x-full"
             class="toast"
             :class="{ 'visible': isRefreshing }">
            <svg class="spinner" width="16" height="16" viewBox="0 0 24 24">
                <path fill="currentColor" d="M12 4V2C6.5 2 2 6.5 2 12H4C4 7.6 7.6 4 12 4ZM12 20V22C17.5 22 22 17.5 22 12H20C20 16.4 16.4 20 12 20ZM12 6C8.7 6 6 8.7 6 12H8C8 9.8 9.8 8 12 8V6ZM12 18C15.3 18 18 15.3 18 12H16C16 14.2 14.2 16 12 16V18Z"/>
            </svg>
            <span>Refreshing book data...</span>
        </div>
    </div>
    
    <!-- Checked Out Books Section -->
    <h3>Your Current Books</h3>
    <table>
        <thead>
            <tr>
                <th>Title</th>
                <th>Author</th>
                <th>Genre</th>
                <th>ISBN</th>
                <th>Publisher</th>
                <th>Published Date</th>
                <th>Page Count</th>
                <th style="width: 110px"></th>
            </tr>
        </thead>
        <tbody>
            <template x-for="book in checkedOutBooks" :key="book.id">
                <tr>
                    <td x-text="book.title"></td>
                    <td x-text="`${book.author.first_name} ${book.author.last_name}`"></td>
                    <td>
                        <span x-text="book.genre.map(g => g.name).join(', ')"></span>
                    </td>
                    <td x-text="book.isbn"></td>
                    <td x-text="book.publisher.name"></td>
                    <td x-text="book.publication_date"></td>
                    <td x-text="book.pages"></td>
                    <td>
                        <button 
                            class="checkout-btn" 
                            @click="returnBook(book.id)" 
                            :disabled="isProcessing">
                                Return Book
                        </button>
                    </td>
                </tr>
            </template>
        </tbody>
    </table>
    <p x-show="checkedOutBooks.length === 0">No books available. Start adding books to your collection now!</p>

    <!-- Available Books Section -->
    <h3 style="margin-top: 150px;">Available Books</h3>
    {% if user.is_staff %}
        <div style="text-align: right; margin-bottom: 20px;">
            <a href="{% url 'add-book' %}" class="btn">Add New Book</a>
        </div>
    {% endif %}
    <table>
        <thead>
            <tr>
                <th>Title</th>
                <th>Author</th>
                <th>Genre</th>
                <th>ISBN</th>
                <th>Publisher</th>
                <th>Published Date</th>
                <th>Page Count</th>
                <th style="width: 110px"></th>
            </tr>
        </thead>
        <tbody>
            <template x-for="book in availableBooks" :key="book.id">
                <tr>
                    <td x-text="book.title"></td>
                    <td x-text="`${book.author.first_name} ${book.author.last_name}`"></td>
                    <td>
                        <span x-text="book.genre.map(g => g.name).join(', ')"></span>
                    </td>
                    <td x-text="book.isbn"></td>
                    <td x-text="book.publisher.name"></td>
                    <td x-text="book.publication_date"></td>
                    <td x-text="book.pages"></td>
                    <td>
                        <button 
                            class="checkout-btn" 
                            @click="checkoutBook(book.id)" 
                            :disabled="isProcessing">
                            Check Out!
                        </button>
                    </td>
                </tr>
            </template>
        </tbody>
    </table>
    <p x-show="availableBooks.length === 0">No books available. Check back later!</p>

    <!-- Unavailable Books Section -->
    <h3 style="margin-top: 150px;">Unavailable Books</h3>
    <table>
        <thead>
            <tr>
                <th>Title</th>
                <th>Author</th>
                <th>Genre</th>
                <th>ISBN</th>
                <th>Publisher</th>
                <th>Published Date</th>
                <th>Page Count</th>
            </tr>
        </thead>
        <tbody>
            <template x-for="book in unavailableBooks" :key="book.id">
                <tr>
                    <td x-text="book.title"></td>
                    <td x-text="`${book.author.first_name} ${book.author.last_name}`"></td>
                    <td>
                        <span x-text="book.genre.map(g => g.name).join(', ')"></span>
                    </td>
                    <td x-text="book.isbn"></td>
                    <td x-text="book.publisher.name"></td>
                    <td x-text="book.publication_date"></td>
                    <td x-text="book.pages"></td>
                </tr>
            </template>
        </tbody>
    </table>
    <p x-show="unavailableBooks.length === 0">All books are available!</p>
</div>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('alpine:init', () => {
        Alpine.data('main', () => ({ 
            books: [],
            availableBooks: [],
            checkedOutBooks: [],
            unavailableBooks: [],
            currentUser: null,
            isProcessing: false,
            refreshInterval: null,
            isRefreshing: false,

            init() {
                this.currentUser = document.querySelector('[x-data="main"]').dataset.userId;
                this.fetchBooks();

                // Set up auto-refresh every 10 seconds
                this.refreshInterval = setInterval(() => {
                    this.fetchBooks();
                }, 10000);

                // Clean up intervals when component is destroyed
                this.$cleanup = () => {
                    if (this.refreshInterval) clearInterval(this.refreshInterval);
                };
            },

            async fetchBooks() {
                this.isRefreshing = true;
                try {
                    const response = await fetch("/api/books");
                    const data = await response.json();

                    await new Promise(resolve => setTimeout(resolve, 3000));

                    this.books = data;
                    this.sortBooks();
                } catch (error) {
                    console.error("Error fetching books:", error);
                } finally {
                    this.isRefreshing = false; // Clear flag when done
                }
            },
            
            sortBooks() {
                const formatDate = (dateString) => {
                    const date = new Date(dateString);
                    return date.toLocaleDateString();
                };
                
                this.books = this.books.map(book => ({
                    ...book,
                    publication_date: formatDate(book.publication_date)
                }));
                
                this.availableBooks = this.books.filter(book => !book.checked_out);
                this.checkedOutBooks = this.books.filter(book => book.checked_out && book.checked_out_by.username === this.currentUser);
                this.unavailableBooks = this.books.filter(book => book.checked_out && book.checked_out_by.username !== this.currentUser);
            },

            async checkoutBook(bookId) {
                this.isProcessing = true;
                this.errorMessage = '';
                try {
                    const book = this.books.find(b => b.id === bookId);
                    const bookTitle = book ? book.title : 'Unknown book';

                    const response = await fetch(`/api/books/${bookId}/checkout/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': this.getCsrfToken()
                        }
                    });

                    if (!response.ok) {
                        const data = await response.json();
                        throw new Error(data.error || 'Failed to checkout book');
                    }

                    console.log(`Check out successful on ${bookTitle}`)
                    await this.fetchBooks();
                } catch (error) {
                    console.error('Error checking out book:', error);
                    this.errorMessage = error.message || 'Failed to checkout book. Please try again.';
                } finally {
                    this.isProcessing = false;
                }
            },

            async returnBook(bookId) {
                this.isProcessing = true;
                this.errorMessage = '';
                try {
                    const book = this.books.find(b => b.id === bookId);
                    const bookTitle = book ? book.title : 'Unknown book';

                    const response = await fetch(`/api/books/${bookId}/checkin/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': this.getCsrfToken()
                        }
                    });

                    if (!response.ok) {
                        const data = await response.json();
                        throw new Error(data.error || 'Failed to return book');
                    }

                    console.log(`Check in successful on: ${bookTitle}`);
                    await this.fetchBooks();
                } catch (error) {
                    console.error('Error returning book:', error);
                    this.errorMessage = error.message || 'Failed to return book. Please try again.';
                } finally {
                    this.isProcessing = false;
                }
            },

            getCsrfToken() {
                const cookieValue = document.cookie
                    .split('; ')
                    .find(row => row.startsWith('csrftoken='))
                    ?.split('=')[1];
                
                if (!cookieValue) {
                    // Fallback to looking for the CSRF input element
                    const tokenElement = document.querySelector('[name=csrfmiddlewaretoken]');
                    return tokenElement ? tokenElement.value : '';
                }
                
                return cookieValue;
            }
        }))
    })
</script>
{% endblock %}